{"version":3,"sources":["connection.tsx","utils.ts","twitter.gif","Home.tsx","Footer.tsx","Navbar.tsx","App.tsx","reportWebVitals.ts","index.tsx","program-functions.ts"],"names":["SequenceType","sendTransactions","connection","wallet","instructionSet","signersSet","a","sequenceType","Parallel","commitment","successCallback","txid","ind","failCallback","block","publicKey","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","instructions","signers","length","transaction","Transaction","forEach","instruction","add","recentBlockhash","blockhash","setSigners","map","s","partialSign","push","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","console","log","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","StopOnFailure","Promise","all","number","txs","getUnixTs","Date","getTime","DEFAULT_TIMEOUT","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","anchor","PublicKey","Home","styled","WalletDialogButton","div","props","useState","setIsUserMinting","numberOfTweets","setNumberOfTweets","tweetProgram","setTweetProgram","open","severity","undefined","setAlertState","rpcHost","useWallet","anchorWallet","useMemo","signTransaction","refreshCandyMachineState","useCallback","programId","getTweetProgramState","cndy","getTweetCount","tweetsNum","onSendTweet","connected","program","document","getElementById","click","sendTweet","mintTxId","txTimeout","msg","code","window","location","reload","indexOf","useEffect","className","alt","src","twitterGif","Button","onClick","Footer","getFullYear","currentYear","ConnectButton","Navbar","Component","theme","createTheme","palette","type","process","getProgramId","network","Connection","App","endpoint","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","PROGRAM_ID","tweet","Keypair","generate","id","account","tweetAccounts","tweetProgramId","provider","preflightCommitment","fetchIdl","idl","TWEET_ID","fetch","state","numberOfTweetsPosted","tweetAccount","payer","accounts","author","systemProgram","SystemProgram","t"],"mappings":"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","file":"static/js/main.0cea2a58.chunk.js","sourcesContent":["import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          // Return the txn we failed on by index\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nexport interface AlertState {\n  open: boolean;\n  message: string;\n  severity: 'success' | 'info' | 'warning' | 'error' | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val?: anchor.BN) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n  new anchor.web3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nexport const getAtaForMint = async (\n  mint: anchor.web3.PublicKey,\n  buyer: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nexport const getNetworkExpire = async (\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nexport const getNetworkToken = async (\n  wallet: anchor.web3.PublicKey,\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n","export default __webpack_public_path__ + \"static/media/twitter.9e527c8d.gif\";","import { useEffect, useMemo, useState, useCallback } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport Button from \"react-bootstrap/Button\";\n\nimport styled from \"styled-components\";\nimport { Container, Snackbar } from \"@material-ui/core\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Alert from \"@material-ui/lab/Alert\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\nimport {\n  awaitTransactionSignatureConfirmation,\n  TweetProgramAccount,\n  PROGRAM_ID,\n  TweetProgramState,\n  Tweet,\n  getTweetCount,\n  sendTweet,\n  getTweetProgramState,\n} from \"./program-functions\";\nimport twitterGif from \"./twitter.gif\";\n\nimport { AlertState } from \"./utils\";\nimport { Header } from \"./Header\";\nimport { MintButton } from \"./MintButton\";\nimport { GatewayProvider } from \"@civic/solana-gateway-react\";\n\nconst ConnectButton = styled(WalletDialogButton)`\n  width: 100%;\n  height: 60px;\n  margin-top: 10px;\n  margin-bottom: 5px;\n  background: linear-gradient(180deg, #b38728 0%, #fbf5b7 100%);\n\n  color: white;\n  font-size: 16px;\n  font-weight: bold;\n`;\n\nconst MintContainer = styled.div``; // add your owns styles here\n\nexport interface HomeProps {\n  programId?: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  txTimeout: number;\n  rpcHost: string;\n}\n\nconst Home = (props: HomeProps) => {\n  const [isUserMinting, setIsUserMinting] = useState(false);\n  const [numberOfTweets, setNumberOfTweets] = useState(0);\n  const [tweetProgram, setTweetProgram] = useState<TweetProgramAccount>();\n  const [tweetContent, setTweetContent] = useState(\"\");\n  const [tweetTopic, setTweetTopic] = useState(\"\");\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  var tweet = {\n    topic: \"Empty topic\",\n    content: \"Empty Content\",\n  };\n\n  const rpcUrl = props.rpcHost;\n  const wallet = useWallet();\n\n  const anchorWallet = useMemo(() => {\n    if (\n      !wallet ||\n      !wallet.publicKey ||\n      !wallet.signAllTransactions ||\n      !wallet.signTransaction\n    ) {\n      return;\n    }\n\n    return {\n      publicKey: wallet.publicKey,\n      signAllTransactions: wallet.signAllTransactions,\n      signTransaction: wallet.signTransaction,\n    } as anchor.Wallet;\n  }, [wallet]);\n\n  const refreshCandyMachineState = useCallback(async () => {\n    console.log(\"I am here in refresh machine\");\n    if (!anchorWallet) {\n      return;\n    }\n\n    console.log(\"I am here in  code\");\n\n    if (props.programId) {\n      try {\n        const cndy = await getTweetProgramState(\n          anchorWallet,\n          props.programId,\n          props.connection\n        );\n        setTweetProgram(cndy);\n        console.log(\"cndy is :\" + cndy);\n\n        const tweetsNum = await getTweetCount(cndy);\n        setNumberOfTweets(tweetsNum);\n        console.log(\"Total number of Tweets are :\" + tweetsNum);\n      } catch (e) {\n        console.log(\"There was a problem fetching Tweet program state\");\n        console.log(e);\n      }\n    }\n  }, [anchorWallet, props.programId, props.connection]);\n\n  const onSendTweet = async () => {\n    try {\n      console.log(\n        \"I am in sendTweet function \" +\n          wallet.connected +\n          \" : \" +\n          tweetProgram?.program +\n          \" : \" +\n          wallet.publicKey\n      );\n\n      setIsUserMinting(true);\n      document.getElementById(\"#identity\")?.click();\n\n      if (wallet.connected && tweetProgram?.program && wallet.publicKey) {\n        const mintTxId = (await sendTweet(tweetProgram, wallet.publicKey))[0];\n        console.log(\"The tx id is :\" + mintTxId);\n\n        let status: any = { err: true };\n        if (mintTxId) {\n          status = await awaitTransactionSignatureConfirmation(\n            mintTxId,\n            props.txTimeout,\n            props.connection,\n            true\n          );\n        }\n\n        if (status && !status.err) {\n          setAlertState({\n            open: true,\n            message: \"Congratulations! Mint succeeded!\",\n            severity: \"success\",\n          });\n        } else {\n          setAlertState({\n            open: true,\n            message: \"Mint failed! Please try again!\",\n            severity: \"error\",\n          });\n        }\n      }\n    } catch (error: any) {\n      let message = error.msg || \"Minting failed! Please try again!\";\n      if (!error.msg) {\n        if (!error.message) {\n          message = \"Transaction Timeout! Please try again.\";\n        } else if (error.message.indexOf(\"0x137\")) {\n          message = `SOLD OUT!`;\n        } else if (error.message.indexOf(\"0x135\")) {\n          message = `Insufficient funds to mint. Please fund your wallet.`;\n        }\n      } else {\n        if (error.code === 311) {\n          message = `SOLD OUT!`;\n          window.location.reload();\n        } else if (error.code === 312) {\n          message = `Minting period hasn't started yet.`;\n        }\n      }\n\n      setAlertState({\n        open: true,\n        message,\n        severity: \"error\",\n      });\n    } finally {\n      setIsUserMinting(false);\n    }\n  };\n\n  useEffect(() => {\n    refreshCandyMachineState();\n  }, [\n    anchorWallet,\n    props.programId,\n    props.connection,\n    refreshCandyMachineState,\n  ]);\n\n  return (\n    <div className=\"mainHomeBlock\">\n      <div className=\"experimental50\">\n        <div className=\" mainComponentFrame\">\n          <img alt=\" \" className=\"mainSolqueenGif\" src={twitterGif} />\n        </div>\n\n        <div className=\"combinedIntroAndBuy\">\n          <div className=\"introContent\">\n            <h1 className=\"celebrate gradText\">SolanaTwitter</h1>\n            <p>\n              <b className=\"celebrate\">\n                <i>\n                  {\" \"}\n                  <h4 className=\"celebrate\"> Let's roll the luck ! </h4>\n                </i>{\" \"}\n              </b>\n              <br></br>\n            </p>\n            {/* \n            <Container>\n              <Container maxWidth=\"xs\" style={{ position: \"relative\" }}>\n                <Paper\n                  style={{\n                    padding: 24,\n                    backgroundColor: \"#1C1B1A\",\n                    borderRadius: 6,\n                  }}\n                >\n                  {!wallet.connected ? (\n                    <ConnectButton className=\"gradientClass\">\n                      Connect Wallet\n                    </ConnectButton>\n                  ) : (\n                    <>\n                      <Header tweetProgram={tweetProgram} />\n\n                      <MintButton\n                        tweetProgram={tweetProgram}\n                        onSendTweet={onSendTweet}\n                        isMinting={isUserMinting}\n                      />\n                    </>\n                  )}\n                </Paper>\n              </Container>\n\n              <Snackbar\n                open={alertState.open}\n                autoHideDuration={6000}\n                onClose={() => setAlertState({ ...alertState, open: false })}\n              >\n                <Alert\n                  onClose={() => setAlertState({ ...alertState, open: false })}\n                  severity={alertState.severity}\n                >\n                  {alertState.message}\n                </Alert>\n              </Snackbar>\n            </Container> */}\n\n            <Button onClick={onSendTweet}>Send tweet</Button>\n\n            {/* <h4 className=\"celebrate\">Find as many accessories for your Queen</h4> */}\n\n            <h4 className=\"gradText\">Tweet Count is : {numberOfTweets} </h4>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Home;\n","import React, { useState } from \"react\";\n// import { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n// import {\n//     faDiscord,\n//     faTwitter,\n//     faMedium,\n// } from \"@fortawesome/free-brands-svg-icons\";\n\nexport default function Footer() {\n  const [currentYear] = useState(new Date().getFullYear());\n  return (\n    <div className=\"social-container\">\n      <div className=\"social-links\">\n        <div className=\"pink-link copyrightContainer\">\n          Copyright &#169; {currentYear} SolanaTwitter\n        </div>\n\n        {/* <Link className = \"pink-link\" to=\"/tc\" >\n\n                    <a className=\"footerLinks social\">\n                        Terms and Conditions\n                    </a>\n                </Link> */}\n\n        {/* <a href=\"mailto:contact@solqueens.com\"\n                    className=\"pink-link social\" >\n                    Contact us\n                    </a> */}\n\n        {/* <Link className=\"pink-link\" to=\"/faq\" >\n                    <a className=\"social\">\n                        FAQ\n                    </a>\n                </Link> */}\n\n        {/* <Link className=\"pink-link\" to=\"/disclaimer\" >\n                    <a className=\"social\">\n                        Disclaimer\n                    </a>\n                </Link> */}\n\n        {/* <a\n                    href=\"https://discord.gg/akncVEYvRW\"\n\n                    className=\"discord social\"\n                >\n                    <FontAwesomeIcon icon={faDiscord} size=\"2x\" />\n                </a> */}\n\n        {/* <a \n                 href=\"https://twitter.com/SolQueensNFT\"\n\n                className=\"twitter social\">\n                    <FontAwesomeIcon icon={faTwitter} size=\"2x\" />\n                </a> */}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\n\nimport \"./App.css\";\nimport styled from \"styled-components\";\n\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav className=\"navBarItems\">\n        <div className=\"navbarLogo\">\n          <h2 className=\"gradTextFancyFont\">SolanaTwitter</h2>\n        </div>\n\n        <ul className=\"navMenu\">\n          <li className=\"navLinks\"></li>\n\n          <li className=\"navLinks\"></li>\n\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n          <li className=\"navLinks\"></li>\n\n          <li className=\"navLinks\">\n            <ConnectButton className=\"gradientClass\">\n              <b>Connect Wallet</b>\n            </ConnectButton>\n          </li>\n        </ul>\n      </nav>\n    );\n  }\n}\n\nexport default Navbar;\n","import \"./App.css\";\nimport { useMemo } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport Home from \"./Home\";\nimport Footer from \"./Footer\";\nimport Navbar from \"./Navbar\";\n// import QueenDisplay from \"./QueenDisplay\";\n// import Roadmap2 from \"./Roadmap2\";\n\n// import Team from \"./Team\";\n\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n  getPhantomWallet,\n  getSlopeWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolletExtensionWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\n\nimport { ThemeProvider, createTheme } from \"@material-ui/core\";\n\nconst theme = createTheme({\n  palette: {\n    type: \"dark\",\n  },\n});\n\nconst getProgramId = (): anchor.web3.PublicKey | undefined => {\n  try {\n    const programId = new anchor.web3.PublicKey(\n      process.env.REACT_APP_PROGRAM_ID!\n    );\n    console.log(\"I am in getprogramID function : \" + programId);\n\n    return programId;\n  } catch (e) {\n    console.log(\"Failed to construct PROGRAMID\", e);\n    return undefined;\n  }\n};\n\nconst programId = getProgramId();\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst txTimeoutInMilliseconds = 30000;\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getSlopeWallet(),\n      getSolletWallet({ network }),\n      getSolletExtensionWallet({ network }),\n    ],\n    []\n  );\n\n  return (\n    <ThemeProvider theme={theme}>\n      <ConnectionProvider endpoint={endpoint}>\n        <WalletProvider wallets={wallets} autoConnect>\n          <WalletDialogProvider>\n            <div className=\"backgroundPaper\">\n              <Navbar />\n              <Home\n                programId={programId}\n                connection={connection}\n                txTimeout={txTimeoutInMilliseconds}\n                rpcHost={rpcHost}\n              />\n\n              <Footer />\n            </div>\n          </WalletDialogProvider>\n        </WalletProvider>\n      </ConnectionProvider>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { BorderBottom } from \"@material-ui/icons\";\nimport * as anchor from \"@project-serum/anchor\";\nimport * as fs from \"fs\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport { sendTransactions } from \"./connection\";\n\nimport {\n  getAtaForMint,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from \"./utils\";\n\nexport const PROGRAM_ID = new anchor.web3.PublicKey(\n  \"BwwdesmeES3kJRxNJduM9rE6DfojzEC6DwQJveWqEW5s\"\n);\n\nexport interface Tweet {\n  author: anchor.web3.PublicKey;\n  timestamp: number;\n  content: String;\n  topic: String;\n}\n\nexport interface TweetProgramState {\n  numberOfTweetsPosted: number;\n}\n\nexport interface TweetProgramAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: TweetProgramState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getTweetCount = async (\n  tweetProgram: TweetProgramAccount\n): Promise<number> => {\n  const tweet = anchor.web3.Keypair.generate();\n\n  const tweetProgramId = tweetProgram.id;\n  const signers: anchor.web3.Keypair[] = [tweet];\n\n  const tweetAccounts: anchor.ProgramAccount<Tweet>[] =\n    await tweetProgram.program.account.tweet.all();\n\n  console.log(tweetAccounts);\n\n  return tweetAccounts.length;\n};\n\nexport const getTweetProgramState = async (\n  anchorWallet: anchor.Wallet,\n  tweetProgramId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection\n): Promise<TweetProgramAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: \"recent\",\n  });\n\n  console.log(\"Nandi : \" + tweetProgramId);\n\n  const idl = await anchor.Program.fetchIdl(PROGRAM_ID, provider);\n\n  const program = new anchor.Program(idl, tweetProgramId, provider);\n\n  const TWEET_ID = new anchor.web3.PublicKey(\n    \"6pin1rik2Ny7VSmAAAdstnEicfNmhWGSezAhRZwUQP8k\"\n  );\n\n  const state: any = await program.account.tweet.fetch(TWEET_ID);\n\n  const numberOfTweetsPosted = state.numberOfTweetsPosted;\n\n  console.log(\"Hi hi\");\n\n  return {\n    id: tweetProgramId,\n    program,\n    state: {\n      numberOfTweetsPosted,\n    },\n  };\n};\n\nexport const sendTweet = async (\n  tweetAccount: TweetProgramAccount,\n  payer: anchor.web3.PublicKey\n): Promise<(string | undefined)[]> => {\n  // We need to ourself pass the tweet acoount id by generating it\n  console.log(\"Now I am in program-functions sendTweet function\");\n  const tweet = anchor.web3.Keypair.generate();\n\n  const tweetProgramId = tweetAccount.id;\n  const signers: anchor.web3.Keypair[] = [tweet];\n\n  const instructions = [];\n\n  var topic = \"Topic Tweet\";\n  var content = \"Content Tweet\";\n\n  // Putting the instruction in instruction quee, and sending it all as a transaction\n  instructions.push(\n    await tweetAccount.program.instruction.sendTweet(topic, content, {\n      accounts: {\n        tweet: tweet.publicKey,\n        author: payer,\n        systemProgram: anchor.web3.SystemProgram.programId,\n      },\n      signers: [tweet],\n    })\n  );\n\n  try {\n    return (\n      await sendTransactions(\n        tweetAccount.program.provider.connection,\n        tweetAccount.program.provider.wallet,\n        [instructions],\n        [signers, []]\n      )\n    ).txs.map((t) => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n"],"sourceRoot":""}